---
title: Spring Cloud 微服务实战
sidebar: auto
---

## 基础

### 微服务的挑战

-   运维的新挑战
-   接口的一致性
-   分布式的复杂性

### 微服务的九大特性

-   服务组建化
-   按业务组织团队
-   做“产品”的态度
-   智能端点与哑管道
-   去中心化治理
-   去中心化管理数据
-   基础设施自动化
    -   自动化测试
    -   自动化部署
-   容错设计

## Spring boot

### Spring boot 的加载顺序

1. 命令行中传入的参数
2. `SPRING_APPLICATION_JSON`中的属性
3. `java:comp/env`中的 JNDI 属性
4. Java 的系统属性
5. 操作系统的环境变量
6. 通过`random.*`配置的随机属性
7. 位于 jar 包之外，针对不同`{profile}`环境的配置文件内容
8. 位于当前应用 jar 包之内，针对不同`{profile}`环境的配置文件内容
9. 位于当前应用 jar 包之外的`application.properties`和 YAML 配置内容
10. 位于当前应用 jar 包之内的`application.properties`和 YAML 配置内容
11. 在`@Configuration`注解修改的类中，通过`@PropertySource`注解定义的属性
12. 应用默认属性

### 原生端点

-   应用配置类
-   度量指标类
-   操作控制类

## 服务治理

服务治理包含：

-   服务注册中心
-   服务提供者
-   服务消费者

Euraka 中有 Regoion 和 Zone 的概念，一个 Regoin 可以包含多个 Zone，每个服务客户端需要被注册到一个 Zone 中，所以每个客户端对应一个 Regoin 和一个 Zone

Jersery 是 JAX-RS 的参考实现：

-   核心服务器
-   核心客户端
-   集成

## 负载均衡

硬件负载均衡主要通过在服务器节点之间安装专门用于负载均衡的设备，而软件负载均衡则
是通过在服务器上安装一些具有均衡负载功能或模块的软件来完成请求分发工作

## 容错保护

### 依赖隔离

通过实现对依赖服务的线程池隔离，可以带来的优势：

-   应用自身得到完全保护，不会受不可控的依赖服务影响
-   可以有效降低接入新服务的风险
-   当依赖的服务出现配置错误的时候，线程池会快速反映出此问题
-   当依赖的服务因实现机制调整灯原因造成性能出现很大变化的时候，线程池的监控指标信息会反映出这样的变化
-   每个专有线程池都提供了内置的并非实现，可以利用它为同步的依赖构建异步访问

## 网关

### API 网关的重要性

-   作为系统的统一入口，屏蔽了系统内部各个微服务的细节
-   可以与服务治理框架接口，实现自动化的服务实例维护以及复杂均衡路由的转发
-   可以实现接口权限与微服务业务逻辑的接耦
-   通过服务网关中的过滤器，保证了微服务的无状态性，同时降低了微服务的测试难度，让服务本身更集中关注业务逻辑的处理

## 消息总线

消息代理是一种消息验证、传输、路由的架构模式

AMQP 与 JMS 不同，JMS 定义了一个 API 和一组消息收发必须实现的行为，而 AMQP 是一个线路级路由

Kafka 是基于消息发布——订阅模式实现的消息系统，其主要设计目的是：

-   消息的持久化
-   高吞吐
-   分布式
-   跨平台
-   实时性
-   伸缩性

Spring 的事件驱动模型包含了三个基本概念：事件、事件监听和事件发布者

Spring Cloud Stream 的核心概念：

-   Binder
-   发布——订阅模式
-   Consumer
-   消息分区

一个典型的 Binder 绑定器实现包括的内容：

-   一个实现 Binder 接口的类
-   一个 Spring 配置加载类，用来创建连接消息中间件的基础结构使用的实例
-   一个或多个能在 classpath 下 META-INF/spring.binders 路径找到的绑定器定义文件

## 链路追踪

分布式系统中服务跟踪主要包含两个关键点：

-   为了实现请求追踪，当请求发送打分布式系统的入口端时，只需要服务跟踪框架为该请求创建一个唯一的跟踪标识，同时在分布式系统内部流转的时候，框架始终传递该唯一标识，知道请求方返回为止
-   为了统计各处理单元的时间延迟，当请求到达各个服务组建时，或是处理逻辑到达某个状态时，也通过一个唯一标识来标记它的开始、具体过程以及结束
